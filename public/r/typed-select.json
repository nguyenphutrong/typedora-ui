{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "typed-select",
  "type": "registry:component",
  "title": "TypedSelect",
  "description": "A headless, type-safe select component with full TypeScript inference and customizable rendering.",
  "registryDependencies": [
    "select",
    "https://typedora-ui.netlify.app/r/typed-utils.json"
  ],
  "files": [
    {
      "path": "registry/default/typed-select/typed-select.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport {\n  Select,\n  SelectContent,\n  SelectGroup,\n  SelectItem,\n  SelectLabel,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\nimport type { ExtractOption, ExtractOptionValue } from \"@/lib/typed-utils\";\n\n// =============================================================================\n// Types\n// =============================================================================\n\n/**\n * Supported value types for TypedSelect.\n * Values are serialized to strings internally but typed correctly externally.\n */\nexport type SelectValueType = string | number | boolean;\n\n/**\n * Default option type with value and label.\n * Use this as a reference for your custom option types.\n */\nexport type SelectOption<T extends SelectValueType = string> = {\n  value: T;\n  label: string;\n  disabled?: boolean;\n};\n\n/**\n * A group of select options with a label.\n * @template TOption - The full option type including custom properties\n */\nexport type SelectOptionGroup<TOption> = {\n  label: string;\n  options: TOption[];\n};\n\n// =============================================================================\n// Render Props Types\n// =============================================================================\n\n/**\n * Props passed to renderTrigger function.\n * @template TOption - The full option type including custom properties\n */\nexport type SelectTriggerRenderProps<TOption> = {\n  /** Currently selected option (undefined if none) */\n  selectedOption: TOption | undefined;\n  /** Placeholder text */\n  placeholder: string;\n  /** Whether the select is open */\n  open: boolean;\n  /** Whether the select is disabled */\n  disabled: boolean;\n  /** Default trigger component */\n  Trigger: typeof SelectTrigger;\n  /** Default value component */\n  Value: typeof SelectValue;\n};\n\n/**\n * Props passed to renderItem function.\n * @template TOption - The full option type including custom properties\n */\nexport type SelectItemRenderProps<TOption> = {\n  /** The option data */\n  option: TOption;\n  /** Whether this option is currently selected */\n  isSelected: boolean;\n  /** Whether this option is disabled */\n  isDisabled: boolean;\n  /** Group this option belongs to (undefined if ungrouped) */\n  group: SelectOptionGroup<TOption> | undefined;\n  /** Props to spread on SelectItem */\n  itemProps: {\n    value: string;\n    disabled?: boolean;\n  };\n  /** Default item component */\n  Item: typeof SelectItem;\n};\n\n/**\n * Props passed to renderGroup function.\n * @template TOption - The full option type including custom properties\n */\nexport type SelectGroupRenderProps<TOption> = {\n  /** The group data */\n  group: SelectOptionGroup<TOption>;\n  /** Rendered items inside this group */\n  children: React.ReactNode;\n  /** Default group component */\n  Group: typeof SelectGroup;\n  /** Default label component */\n  Label: typeof SelectLabel;\n};\n\n/**\n * Props passed to renderContent function.\n */\nexport type SelectContentRenderProps = {\n  /** Rendered items/groups */\n  children: React.ReactNode;\n  /** Default content component */\n  Content: typeof SelectContent;\n};\n\n/**\n * Core props for TypedSelect (for documentation).\n * The actual component also accepts all Select props.\n */\nexport interface TypedSelectBaseProps<\n  TOptions extends\n    | readonly Record<string, unknown>[]\n    | readonly SelectOptionGroup<Record<string, unknown>>[],\n  TValueKey extends string = \"value\",\n  TLabelKey extends string = \"label\",\n> {\n  /** Array of options or grouped options */\n  options: TOptions;\n  /** The key to use for the option value (default: \"value\") */\n  valueKey?: TValueKey;\n  /** The key to use for the option label (default: \"label\") */\n  labelKey?: TLabelKey;\n  /** Controlled value */\n  value?: ExtractOptionValue<TOptions, TValueKey>;\n  /** Default value for uncontrolled usage */\n  defaultValue?: ExtractOptionValue<TOptions, TValueKey>;\n  /** Callback when value changes - receives the typed value */\n  onChange?: (value: ExtractOptionValue<TOptions, TValueKey>) => void;\n  /** Placeholder text (passed to renderTrigger) */\n  placeholder?: string;\n  /** Custom render for trigger */\n  renderTrigger?: (\n    props: SelectTriggerRenderProps<ExtractOption<TOptions>>,\n  ) => React.ReactNode;\n  /** Custom render for each item */\n  renderItem?: (\n    props: SelectItemRenderProps<ExtractOption<TOptions>>,\n  ) => React.ReactNode;\n  /** Custom render for each group (required when using grouped options) */\n  renderGroup?: (\n    props: SelectGroupRenderProps<ExtractOption<TOptions>>,\n  ) => React.ReactNode;\n  /** Custom render for content wrapper */\n  renderContent?: (props: SelectContentRenderProps) => React.ReactNode;\n  /** Whether the select is disabled */\n  disabled?: boolean;\n  /** Whether the select is open (controlled) */\n  open?: boolean;\n  /** Callback when open state changes */\n  onOpenChange?: (open: boolean) => void;\n  /** The name of the select (for form submission) */\n  name?: string;\n  /** Whether selection is required */\n  required?: boolean;\n}\n\n/**\n * Props for the TypedSelect component.\n * @template TOptions - The options array type\n * @template TValueKey - The key used for the value property (default: \"value\")\n * @template TLabelKey - The key used for the label property (default: \"label\")\n */\nexport interface TypedSelectProps<\n  TOptions extends\n    | readonly Record<string, unknown>[]\n    | readonly SelectOptionGroup<Record<string, unknown>>[],\n  TValueKey extends string = \"value\",\n  TLabelKey extends string = \"label\",\n> extends Omit<\n      React.ComponentProps<typeof Select>,\n      \"value\" | \"defaultValue\" | \"onValueChange\" | \"children\"\n    >,\n    TypedSelectBaseProps<TOptions, TValueKey, TLabelKey> {}\n\n// =============================================================================\n// Helpers\n// =============================================================================\n\n/**\n * Type guard to check if options are grouped\n */\nfunction isGroupedOptions<TOption>(\n  options: readonly TOption[] | readonly SelectOptionGroup<TOption>[],\n): options is readonly SelectOptionGroup<TOption>[] {\n  return options.length > 0 && \"options\" in (options[0] as object);\n}\n\n/**\n * Serialize a value to string for internal use with Radix Select\n */\nfunction serializeValue<T extends SelectValueType>(value: T): string {\n  if (typeof value === \"boolean\") {\n    return value ? \"__boolean_true__\" : \"__boolean_false__\";\n  }\n  if (typeof value === \"number\") {\n    return `__number_${value}__`;\n  }\n  return String(value);\n}\n\n/**\n * Deserialize a string value back to its original type\n */\nfunction deserializeValue<TOption extends Record<string, unknown>>(\n  serialized: string,\n  options: readonly TOption[] | readonly SelectOptionGroup<TOption>[],\n  valueKey: keyof TOption,\n): TOption[keyof TOption] {\n  const allOptions = isGroupedOptions(options)\n    ? options.flatMap((group) => group.options)\n    : options;\n\n  const found = allOptions.find(\n    (opt) => serializeValue(opt[valueKey] as SelectValueType) === serialized,\n  );\n\n  return found?.[valueKey] as TOption[keyof TOption];\n}\n\n/**\n * Find the selected option object from the current value.\n * Handles both flat and grouped options.\n */\nfunction findSelectedOption<TOption extends Record<string, unknown>>(\n  value: TOption[keyof TOption] | undefined,\n  options: readonly TOption[] | readonly SelectOptionGroup<TOption>[],\n  valueKey: keyof TOption,\n): TOption | undefined {\n  if (value === undefined) return undefined;\n\n  const allOptions = isGroupedOptions(options)\n    ? options.flatMap((group) => group.options)\n    : options;\n\n  return allOptions.find((opt) => opt[valueKey] === value);\n}\n\n// =============================================================================\n// Default Render Functions\n// =============================================================================\n\nfunction defaultRenderTrigger<TOption>({\n  placeholder,\n  Trigger,\n  Value,\n}: SelectTriggerRenderProps<TOption>): React.ReactNode {\n  return (\n    <Trigger>\n      <Value placeholder={placeholder} />\n    </Trigger>\n  );\n}\n\nfunction createDefaultRenderItem<\n  TOption extends Record<string, unknown>,\n  TLabelKey extends keyof TOption,\n>(labelKey: TLabelKey) {\n  return function defaultRenderItem({\n    option,\n    itemProps,\n    Item,\n  }: SelectItemRenderProps<TOption>): React.ReactNode {\n    const label = option[labelKey];\n    return <Item {...itemProps}>{String(label ?? \"\")}</Item>;\n  };\n}\n\nfunction defaultRenderContent({\n  children,\n  Content,\n}: SelectContentRenderProps): React.ReactNode {\n  return <Content>{children}</Content>;\n}\n\n// =============================================================================\n// Component\n// =============================================================================\n\n/**\n * A headless, type-safe select component with full TypeScript inference\n * and customizable rendering via render props.\n *\n * @example\n * ```tsx\n * // Default usage with value/label keys\n * <TypedSelect\n *   placeholder=\"Select fruit\"\n *   options={[\n *     { value: \"apple\", label: \"Apple\" },\n *     { value: \"banana\", label: \"Banana\", description: \"Yellow fruit\" },\n *   ] as const}\n *   renderTrigger={({ placeholder, selectedOption, Trigger, Value }) => (\n *     <Trigger>\n *       <Value placeholder={placeholder} />\n *     </Trigger>\n *   )}\n *   renderItem={({ option, itemProps, Item }) => (\n *     <Item {...itemProps}>\n *       <div>\n *         <span>{option.label}</span>\n *         {option.description && <p>{option.description}</p>}\n *       </div>\n *     </Item>\n *   )}\n *   renderContent={({ children, Content }) => (\n *     <Content>{children}</Content>\n *   )}\n *   onChange={(value) => {\n *     // value: \"apple\" | \"banana\"\n *   }}\n * />\n *\n * // Custom keys usage with id/name\n * <TypedSelect\n *   placeholder=\"Select user\"\n *   options={[\n *     { id: 1, name: \"John Doe\" },\n *     { id: 2, name: \"Jane Smith\" },\n *   ] as const}\n *   valueKey=\"id\"\n *   labelKey=\"name\"\n *   onChange={(value) => {\n *     // value: 1 | 2\n *   }}\n * />\n * ```\n */\nfunction TypedSelect<\n  TOptions extends\n    | readonly Record<string, unknown>[]\n    | readonly SelectOptionGroup<Record<string, unknown>>[],\n  TValueKey extends string = \"value\",\n  TLabelKey extends string = \"label\",\n>({\n  options,\n  valueKey = \"value\" as TValueKey,\n  labelKey = \"label\" as TLabelKey,\n  value,\n  defaultValue,\n  onChange,\n  placeholder = \"Select an option\",\n  open: controlledOpen,\n  onOpenChange,\n  disabled = false,\n  renderTrigger = defaultRenderTrigger,\n  renderItem,\n  renderGroup,\n  renderContent = defaultRenderContent,\n  ...props\n}: TypedSelectProps<TOptions, TValueKey, TLabelKey>) {\n  // Extract the actual option type for internal use\n  type TOption = ExtractOption<TOptions> & Record<string, unknown>;\n  type TValue = ExtractOptionValue<TOptions, TValueKey>;\n\n  // Track open state internally\n  const [internalOpen, setInternalOpen] = React.useState(false);\n  const open = controlledOpen ?? internalOpen;\n\n  // Track internal value for uncontrolled mode\n  const [internalValue, setInternalValue] = React.useState<TValue | undefined>(\n    defaultValue,\n  );\n\n  // Use controlled value if provided, otherwise use internal state\n  const currentValue = value !== undefined ? value : internalValue;\n\n  const handleOpenChange = (newOpen: boolean) => {\n    setInternalOpen(newOpen);\n    onOpenChange?.(newOpen);\n  };\n\n  const handleValueChange = (serialized: string) => {\n    const deserialized = deserializeValue(\n      serialized,\n      options as readonly TOption[] | readonly SelectOptionGroup<TOption>[],\n      valueKey as keyof TOption,\n    );\n\n    // Update internal state for uncontrolled mode\n    if (value === undefined) {\n      setInternalValue(deserialized as TValue);\n    }\n\n    if (onChange) {\n      onChange(deserialized as TValue);\n    }\n  };\n\n  const selectedOption = findSelectedOption(\n    currentValue as TOption[keyof TOption] | undefined,\n    options as readonly TOption[] | readonly SelectOptionGroup<TOption>[],\n    valueKey as keyof TOption,\n  );\n  const serializedValue =\n    currentValue !== undefined\n      ? serializeValue(currentValue as SelectValueType)\n      : undefined;\n  const serializedDefaultValue =\n    defaultValue !== undefined\n      ? serializeValue(defaultValue as SelectValueType)\n      : undefined;\n\n  // Use provided renderItem or create default with labelKey\n  const actualRenderItem =\n    renderItem ??\n    createDefaultRenderItem<TOption, keyof TOption>(labelKey as keyof TOption);\n\n  // Render a single item\n  const renderSingleItem = (\n    option: TOption,\n    group: SelectOptionGroup<TOption> | undefined,\n  ) => {\n    const optionValue = option[valueKey as keyof TOption] as SelectValueType;\n    const serialized = serializeValue(optionValue);\n    const isSelected = serializedValue === serialized;\n    const isDisabled = (option as { disabled?: boolean }).disabled ?? false;\n\n    return (\n      <React.Fragment key={serialized}>\n        {actualRenderItem({\n          option,\n          isSelected,\n          isDisabled,\n          group,\n          itemProps: {\n            value: serialized,\n            disabled: isDisabled,\n          },\n          Item: SelectItem,\n        })}\n      </React.Fragment>\n    );\n  };\n\n  // Render all items (grouped or flat)\n  const renderItems = () => {\n    const opts = options as\n      | readonly TOption[]\n      | readonly SelectOptionGroup<TOption>[];\n\n    if (isGroupedOptions(opts)) {\n      return opts.map((group) => {\n        const groupChildren = group.options.map((option) =>\n          renderSingleItem(option, group),\n        );\n\n        if (renderGroup) {\n          return (\n            <React.Fragment key={group.label}>\n              {renderGroup({\n                group: group as SelectOptionGroup<ExtractOption<TOptions>>,\n                children: groupChildren,\n                Group: SelectGroup,\n                Label: SelectLabel,\n              })}\n            </React.Fragment>\n          );\n        }\n\n        // Default group rendering if renderGroup not provided\n        return (\n          <SelectGroup key={group.label}>\n            <SelectLabel>{group.label}</SelectLabel>\n            {groupChildren}\n          </SelectGroup>\n        );\n      });\n    }\n\n    return (opts as readonly TOption[]).map((option) =>\n      renderSingleItem(option, undefined),\n    );\n  };\n\n  return (\n    <Select\n      value={serializedValue}\n      defaultValue={serializedDefaultValue}\n      onValueChange={handleValueChange}\n      open={open}\n      onOpenChange={handleOpenChange}\n      disabled={disabled}\n      {...props}\n    >\n      {renderTrigger({\n        selectedOption: selectedOption as ExtractOption<TOptions> | undefined,\n        placeholder,\n        open,\n        disabled,\n        Trigger: SelectTrigger,\n        Value: SelectValue,\n      })}\n      {renderContent({\n        children: renderItems(),\n        Content: SelectContent,\n      })}\n    </Select>\n  );\n}\n\nexport { TypedSelect };\n",
      "type": "registry:component"
    }
  ]
}
